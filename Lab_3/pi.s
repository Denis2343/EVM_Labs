.LC4:
        .string "It took me %d clicks (%f seconds).\n"
main:
        leal    4(%esp), %ecx            //загрузить адресс %esp + 4  в ecx
        andl    $-16, %esp				 //логическое И -16 с %esp с записью результата в %esp || сдвиг esp в стеке на 16 элементов вверх
        pushl   -4(%ecx)				 //уменьшает вершину стека на 4 байта и помещает на вершину стека -4(%ecx)		
        pushl   %ebp                     //уменьшает вершину стека на 4 байта и помещает на вершину стека %ebp
        movl    %esp, %ebp               //%ebp теперь также указывает на текущую вершину стека
        pushl   %ecx                     //уменьшает вершину стека на 4 байта и помещает на вершину стека %ecx
        subl    $52, %esp				 //%esp = %esp - 52
        call    clock					 //вызов подпрограммы clock
        movl    %eax, -36(%ebp)          //копирует %eax в -36(%ebp)
        fldz							 //загрузка нуля на вершину стека сопроцессора
        fstpl   -16(%ebp)				 //Сохранить st(0) в -16(%ebp), верхний элемент выталкивается из стека сопроцессора
        movl    $705032704, -48(%ebp)    //копировать число $70... в -48(%ebp)
        movl    $1, -44(%ebp)			 //копировать 1 в -44(%ebp)
        movl    $1, -20(%ebp)			 //копировать 1 в -20(%ebp)
        movl    $0, -32(%ebp)			 //копировать 0 в -32(%ebp)
        movl    $0, -28(%ebp)			 //копировать 0 в -28(%ebp)
        jmp     .L2						 //продолжаем исполнять код с метки .L2
.L3:
        fildl   -20(%ebp)				 //загрузка целого -20(%ebp) в st(0)
        fildq   -32(%ebp)				 //загрузка целого -32(%ebp) в st(0)
        fld     %st(0)					 //загрузка вещественного числа %st(0) в st(0)
        faddp   %st, %st(1)				 //сложение: %st(1) = %st(1) + %st(0) , после этого st(1) выталкивается из стека сопроцессора
        fld1							 //загрузка 1 в st(0)
        faddp   %st, %st(1)				 //сложение: %st(1) = %st(1) + %st(0) , после этого st(1) выталкивается из стека сопроцессора
        fdivrp  %st, %st(1)				 //деление вещественного числа: st(0) = st(1) / st(0) , после этого st(1) выталкивается из стека сопроцессора
        fldl    -16(%ebp)				 //загрузка вещественного числа -16(%ebp) в st(0)
        faddp   %st, %st(1)				 //сложение: %st(1) = %st(1) + %st(0) , после этого st(1) выталкивается из стека сопроцессора
        fstpl   -16(%ebp)				 //сохранить -16(%ebp) в st(0), верхний элемент выталкивается из стека сопроцессора
        negl    -20(%ebp)				 //смена знака -20(%ebp)
        addl    $1, -32(%ebp)			 //сложение: -32(%ebp) = -32(%ebp) + 1
        adcl    $0, -28(%ebp)			 //сложение с переносом: -28(%ebp) = -28(%ebp) + 0 + cf
.L2:
        movl    -32(%ebp), %eax			 //копируем -32(%ebp) в %eax
        movl    -28(%ebp), %edx			 //копируем -28(%ebp) в %edx
        cmpl    -48(%ebp), %eax			 //устанавливаем флаги для -48(%ebp) и %eax
        movl    %edx, %eax				 //копирование %edx в %eax
        sbbl    -44(%ebp), %eax			 //вычитание с заемом: %eax - -44(%ebp)
        jl      .L3						 //продолжаем исполнять код с метки .L3, если -48(%ebp) меньше %eax
        fldl    -16(%ebp)				 //загрузка вещественного числа -16(%ebp) в st(0)
        fldl    .LC2					 //загрузка вещественного числа .LC2 в st(0)
        fmulp   %st, %st(1)				 //умножение вещественного числа: %st(1) = %st(1) * %st(0), после этого st(1) выталкивается из стека сопроцессора
        fstpl   -16(%ebp)				 //сохранить -16(%ebp) в st(0), верхний элемент выталкивается из стека сопроцессора
        call    clock					 //вызов подпрограммы clock
        subl    -36(%ebp), %eax			 //вычитание: %eax = %eax - -36(%ebp
        movl    %eax, -36(%ebp)			 //копирование %eax в -36(%ebp)
        fildl   -36(%ebp)				 //загрузка целого -36(%ebp) в st(0)
        flds    .LC3					 //загрузка вещественного числа .LC3 в st(0)
        fdivrp  %st, %st(1)				 //деление вещественного числа: st(0) = st(1) / st(0) , после этого st(1) выталкивается из стека сопроцессора
        leal    -8(%esp), %esp			 //загрузить адресс -8(%esp) в %esp
        fstpl   (%esp)					 //сохранить (%esp) в st(0), верхний элемент выталкивается из стека сопроцессора
        pushl   -36(%ebp)				 //уменьшает вершину стека на 4 байта и помещает на вершину стека -36(%ebp)
        pushl   $.LC4					 //уменьшает вершину стека на 4 байта и помещает на вершину стека $.LC4
        call    printf					 //вызов подпрограммы printf
        addl    $16, %esp				 //сложение: %esp = %esp + $16
        movl    $0, %eax				 //копирование $0 в %eax
        movl    -4(%ebp), %ecx			 //копирование -4(%ebp) в %ecx
        leave							 //Загрузить в %esp значение из %ebp и считать из нового стека %ebp
        leal    -4(%ecx), %esp			 //загрузить адресс -4(%ecx) в %esp
        ret								 //передача управления по адресу возврата в данном случае -4(%ecx)
.LC2:
        .long   0
        .long   1074790400
.LC3:
        .long   1232348160